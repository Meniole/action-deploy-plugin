name: "Update Manifest and Commit Changes"
description: "Checks out the repository, sets up Node, installs dependencies, updates manifest.json, formats, and commits/pushes changes signing the commit."
inputs:
  manifestPath:
    description: "The path to the manifest.json file."
    required: false
    default: "${{ github.workspace }}/manifest.json"
  schemaPath:
    description: "The path to the plugin settings schema."
    required: false
    default: "${{ github.workspace }}/src/types/plugin-input.ts"
  pluginEntry:
    description: "The path to the plugin entry file."
    required: false
    default: "${{ github.workspace }}/src/index.ts"
  commitMessage:
    description: "The commit message."
    required: false
    default: "chore: updated manifest.json and dist build"
  nodeVersion:
    description: "The version of Node.js to use."
    default: "20.10.0"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Check out the repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.nodeVersion }}

    - name: Install dependencies
      shell: bash
      run: |
        yarn install --immutable --immutable-cache --check-cache

    - name: Build project
      shell: bash
      run: |
        yarn add -DE @vercel/ncc
        echo "Compiling plugin..."
        yarn ncc build --minify ${{ inputs.pluginEntry }} -m -o dist
        echo "Compiling plugin types..."
        yarn ncc build ${{ inputs.schemaPath }} -m -o plugin

    - name: Update manifest configuration JSON
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs').promises;
          const path = require('path');

          async function updateManifest() {
            const manifestPath = '${{ inputs.manifestPath }}';
            const pluginPath = path.resolve('${{ github.workspace }}', 'plugin', 'index.js');

            let pluginSettingsSchema;
            try {
              // First, try to load as ESM
              try {
                const pluginModule = await import(`file://${pluginPath}`);
                pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                if (!pluginSettingsSchema) {
                  throw new Error('pluginSettingsSchema not found in the ESM module');
                }
              } catch (esmError) {
                // If ESM import fails, try loading as CJS
                try {
                  const pluginModule = require(pluginPath);
                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                  if (!pluginSettingsSchema) {
                    throw new Error('pluginSettingsSchema not found in the CJS module');
                  }
                } catch (cjsError) {
                  console.error('Error loading module as ESM and CJS:', esmError, cjsError);
                  process.exit(1);
                }
              }
            } catch (error) {
              console.error('Error loading module:', error);
              process.exit(1);
            }

            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
            manifest["configuration"] = pluginSettingsSchema;

            function customReviver(key, value) {
              if (typeof value === "object" && value !== null) {
                if ("properties" in value && "required" in value) {
                  const requiredFields = new Set(value.required);
                  for (const [propKey, propValue] of Object.entries(value.properties)) {
                    if (typeof propValue === 'object' && 'default' in propValue) {
                      requiredFields.delete(propKey);
                    }
                  }
                  value.required = Array.from(requiredFields);
                  if (value.required.length === 0) {
                    delete value.required;
                  }
                }

                // Recursively apply to nested objects and arrays
                if (Array.isArray(value)) {
                  return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
                } else {
                  return Object.fromEntries(
                    Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
                  );
                }
              }
              return value;
            }

            const updatedManifest = JSON.stringify(manifest, customReviver, 2);
            await fs.writeFile(manifestPath, updatedManifest, 'utf8');
          }

    - name: Format manifest using Prettier
      shell: bash
      run: |
        yarn add -DE prettier
        yarn prettier --write .

    - name: Get GitHub App token
      if: env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
      uses: tibdex/github-app-token@v1.7.0
      id: get_installation_token
      with:
        app_id: ${{ env.APP_ID }}
        private_key: ${{ env.APP_PRIVATE_KEY }}

    - name: Install dependencies
      shell: bash
      run: |
        yarn add "@actions/core" "@actions/github"

    - name: Conditionally update manifest.json and dist folder
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.get_installation_token.outputs.token || github.token }}
      run: |
        node -e '
        const fs = require("fs");
        const path = require("path");
        const core = require("@actions/core");
        const dotenv = require("dotenv");
        const github = require("@actions/github");
        const commitMessage = "${{ inputs.commitMessage }}";
        async function run() {
          try {
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
            const context = github.context;
        
            async function hasFileChanged(filePath) {
              if (!fs.existsSync(filePath)) {
                return true; // File doesn t exist locally, so it s changed
              }
        
              const localContent = fs.readFileSync(filePath, "utf8");
              try {
                const { data: repoFile } = await octokit.rest.repos.getContent({
                  ...context.repo,
                  path: filePath,
                });
                const repoContent = Buffer.from(repoFile.content, "base64").toString(
                  "utf8",
                );
                return localContent !== repoContent;
              } catch (error) {
                if (error.status === 404) {
                  return true; // File doesn t exist in repo, so it s changed
                }
                throw error;
              }
            }
        
            const manifestChanged = await hasFileChanged("manifest.json");
        
            let distChanged = false;
            if (fs.existsSync("dist")) {
              const distFiles = fs.readdirSync("dist", { recursive: true });
              for (const file of distFiles) {
                const filePath = path.join("dist", file);
                if (fs.statSync(filePath).isFile()) {
                  if (await hasFileChanged(filePath)) {
                    distChanged = true;
                    break;
                  }
                }
              }
            }
        
            if (!manifestChanged && !distChanged) {
              console.log("No changes detected. Skipping commit.");
              return;
            }
        
            const newTree = [];
        
            if (manifestChanged) {
              console.log("Manifest changed, will commit");
              const manifestContent = fs.readFileSync("manifest.json", "utf8");
              newTree.push({
                path: "manifest.json",
                mode: "100644",
                type: "blob",
                content: manifestContent,
              });
            }
        
            // Function to recursively add files from a directory to the tree
            function addFilesToTree(dirPath) {
              const files = fs.readdirSync(dirPath);
              for (const file of files) {
                const filePath = path.join(dirPath, file);
                const stats = fs.statSync(filePath);
                if (stats.isDirectory()) {
                  addFilesToTree(filePath);
                } else {
                  const content = fs.readFileSync(filePath, "utf8");
                  newTree.push({
                    path: filePath,
                    mode: "100644",
                    type: "blob",
                    content: content,
                  });
                }
              }
            }
        
            if (distChanged && fs.existsSync("dist")) {
              console.log("Dist changed, will commit");
              addFilesToTree("dist");
            }
        
            const { data: refData } = await octokit.rest.git.getRef({
              ...context.repo,
              ref: `heads/${context.ref.replace("refs/heads/", "")}`,
            });
            const currentSha = refData.object.sha;
        
            const { data: createdTree } = await octokit.rest.git.createTree({
              ...context.repo,
              base_tree: currentSha,
              tree: newTree,
            });
        
            // Create a new commit
            const { data: newCommit } = await octokit.rest.git.createCommit({
              ...context.repo,
              message: commitMessage,
              tree: createdTree.sha,
              parents: [currentSha],
            });
        
            await octokit.rest.git.updateRef({
                ...context.repo,
                ref: `heads/${context.ref.replace("refs/heads/", "")}`,
                sha: newCommit.sha
            });
        
            console.log(
              "Successfully updated manifest.json and/or dist folder contents",
            );
          } catch (error) {
            core.setFailed(error.message);
          }
        }
        
        run();
        '
