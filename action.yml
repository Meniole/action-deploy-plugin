name: "Update Manifest and Commit Changes"
description: "Checks out the repository, sets up Node, installs dependencies, updates manifest.json, formats, and commits/pushes changes signing the commit."
inputs:
  manifestPath:
    description: "The path to the manifest.json file."
    required: false
    default: "${{ github.workspace }}/manifest.json"
  schemaPath:
    description: "The path to the plugin settings schema."
    required: false
    default: "${{ github.workspace }}/src/types/plugin-input.ts"
  pluginEntry:
    description: "The path to the plugin entry file."
    required: false
    default: "${{ github.workspace }}/src/index.ts"
  commitMessage:
    description: "The commit message."
    required: false
    default: "chore: updated manifest.json and dist build"
  nodeVersion:
    description: "The version of Node.js to use."
    default: "20.10.0"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Check out the repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.nodeVersion }}

#    - name: Install dependencies
#      shell: bash
#      run: |
#        yarn install --immutable --immutable-cache --check-cache
#
#    - name: Build project
#      shell: bash
#      run: |
#        yarn add -DE @vercel/ncc
#        echo "Compiling plugin..."
#        yarn ncc build --minify ${{ inputs.pluginEntry }} -m -o dist
#        echo "Compiling plugin types..."
#        yarn ncc build ${{ inputs.schemaPath }} -m -o plugin
#
#    - name: Update manifest configuration JSON
#      uses: actions/github-script@v7
#      with:
#        script: |
#          const fs = require('fs').promises;
#          const path = require('path');
#
#          async function updateManifest() {
#            const manifestPath = '${{ inputs.manifestPath }}';
#            const pluginPath = path.resolve('${{ github.workspace }}', 'plugin', 'index.js');
#
#            let pluginSettingsSchema;
#            try {
#              // First, try to load as ESM
#              try {
#                const pluginModule = await import(`file://${pluginPath}`);
#                pluginSettingsSchema = pluginModule.pluginSettingsSchema;
#
#                if (!pluginSettingsSchema) {
#                  throw new Error('pluginSettingsSchema not found in the ESM module');
#                }
#              } catch (esmError) {
#                // If ESM import fails, try loading as CJS
#                try {
#                  const pluginModule = require(pluginPath);
#                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;
#
#                  if (!pluginSettingsSchema) {
#                    throw new Error('pluginSettingsSchema not found in the CJS module');
#                  }
#                } catch (cjsError) {
#                  console.error('Error loading module as ESM and CJS:', esmError, cjsError);
#                  process.exit(1);
#                }
#              }
#            } catch (error) {
#              console.error('Error loading module:', error);
#              process.exit(1);
#            }
#
#            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
#            manifest["configuration"] = pluginSettingsSchema;
#
#            function customReviver(key, value) {
#              if (typeof value === "object" && value !== null) {
#                if ("properties" in value && "required" in value) {
#                  const requiredFields = new Set(value.required);
#                  for (const [propKey, propValue] of Object.entries(value.properties)) {
#                    if (typeof propValue === 'object' && 'default' in propValue) {
#                      requiredFields.delete(propKey);
#                    }
#                  }
#                  value.required = Array.from(requiredFields);
#                  if (value.required.length === 0) {
#                    delete value.required;
#                  }
#                }
#
#                // Recursively apply to nested objects and arrays
#                if (Array.isArray(value)) {
#                  return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
#                } else {
#                  return Object.fromEntries(
#                    Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
#                  );
#                }
#              }
#              return value;
#            }
#
#            const updatedManifest = JSON.stringify(manifest, customReviver, 2);
#            await fs.writeFile(manifestPath, updatedManifest, 'utf8');
#          }
#
#    - name: Format manifest using Prettier
#      shell: bash
#      run: |
#        yarn add -DE prettier
#        yarn prettier --write .

    - name: Get GitHub App token
      if: env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
      uses: tibdex/github-app-token@v1.7.0
      id: get_installation_token
      with:
        app_id: ${{ env.APP_ID }}
        private_key: ${{ env.APP_PRIVATE_KEY }}

#    - name: Commit and Push changes
#      shell: bash
#      env:
#        GITHUB_TOKEN: ${{ steps.get_installation_token.outputs.token || github.token }}
#      run: |
#        app_token="${{ steps.get_installation_token.outputs.token }}" # Assuming this outputs your app token
#
#        user_info=$(curl -s -H "Authorization: token $app_token" https://api.github.com/user)
#
#        user_name=$(echo "$user_info" | jq -r .name)
#        user_email=$(echo "$user_info" | jq -r .email)
#
#        if [ "$user_email" == "null" ]; then
#          user_email="ubiquity-os[bot]@users.noreply.github.com"
#          user_name="ubiquity-os[bot]"
#        fi
#
#        # Configure Git with the retrieved user information
#        git config --global user.name "$user_name"
#        git config --global user.email "$user_email"
#        # git remote set-url origin https://${{ env.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
#        git remote set-url origin https://x-access-token:${{ env.GITHUB_TOKEN }}@github.com/${{ github.repository }}
#
#        git add "${{ inputs.manifestPath }}"
#        git add -f ${{ github.workspace }}/dist/\*
#        if [ -n "$(git diff-index --cached --name-only HEAD)" ]; then
#          git commit -m "${{ inputs.commitMessage }}" || echo "Commit failed"
#          # Attempt to pull and resolve conflicts
#          git pull origin ${{ github.ref_name }} || {
#            echo "Rebase failed, force pushing changes."
#            git push --force origin HEAD:${{ github.ref_name }}
#            exit 0
#          }
#          git push origin HEAD:${{ github.ref_name }}
#        else
#          echo "No changes to commit"
#        fi

    - name: Commit and Push changes
      uses: actions/github-script@v7
      with:
        github-token: ${{ steps.get_installation_token.outputs.token || github.token }}
        script: |          
          async function run() {
            const octokit = github;
          
            console.log("installation token?", "${{ steps.get_installation_token.outputs.token }}");
          
            // Fetch user info
            //const { data: user } = await octokit.rest.users.getAuthenticated();
            //const userName = user.name || "ubiquity-os[bot]";
            //const userEmail = user.email || "ubiquity-os[bot]@users.noreply.github.com";
          
            //console.log("values", data);
            const repos = await octokit.rest.repos.listForOrg({
              org: "Meniole",
            });
            console.log(JSON.stringify(repos));
          
            // Configure Git with the retrieved user information
            //await exec('git', ['config', '--global', 'user.name', userName]);
            //await exec('git', ['config', '--global', 'user.email', userEmail]);
          
            // Set remote URL
            //await exec('git', ['remote', 'set-url', 'origin', `https://x-access-token:${token}@github.com/${github.context.repo.owner}/${github.context.repo.repo}.git`]);
          
            // Add files to commit
            await exec('git', ['add', core.getInput('manifestPath')]);
            await exec('git', ['add', '-f', `${github.context.workspace}/dist/*`]);
          
            // Check if there are changes to commit
            let changes = '';
            await exec('git', ['diff-index', '--cached', '--name-only', 'HEAD'], [], {
              listeners: {
                stdout: (data) => {
                  changes += data.toString();
                }
              }
            });
          
            if (changes.trim()) {
              try {
                await exec('git', ['commit', '-m', core.getInput('commitMessage')]);
                try {
                  // Attempt to pull and resolve conflicts
                  await exec('git', ['pull', 'origin', github.context.ref.replace('refs/heads/', '')]);
                } catch (error) {
                  console.log('Rebase failed, force pushing changes.');
                  await exec('git', ['push', '--force', 'origin', `HEAD:${github.context.ref.replace('refs/heads/', '')}`]);
                  return;
                }
                await exec('git', ['push', 'origin', `HEAD:${github.context.ref.replace('refs/heads/', '')}`]);
              } catch (error) {
                console.log('Commit failed');
              }
            } else {
              console.log('No changes to commit');
            }
          }
          
          run();